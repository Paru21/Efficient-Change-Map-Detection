# -*- coding: utf-8 -*-
"""Untitled11.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/11Ml3A0xpoRo0hQzFvhwFBhz2fk3AzZAQ
"""

import streamlit as st
import numpy as np
from PIL import Image
import cv2
import matplotlib.pyplot as plt
from sklearn.cluster import KMeans
import cv2
from collections import Counter
from sklearn.decomposition import PCA



def find_FVS(EVS, diff_image, mean_vec, new):
    
    i = 2 
    feature_vector_set = []
    
    while i < new[0] - 2:
        j = 2
        while j < new[1] - 2:
            block = diff_image[i-2:i+3, j-2:j+3]
            feature = block.flatten()
            feature_vector_set.append(feature)
            j = j+1
        i = i+1
        
    FVS = np.dot(feature_vector_set, EVS)
    FVS = FVS - mean_vec
    #print("\nfeature vector space size",FVS.shape)
    return FVS

def clustering(FVS, components, new):
    
    kmeans = KMeans(components, verbose = 0)
    kmeans.fit(FVS)
    output = kmeans.predict(FVS)
    count  = Counter(output)

    least_index = min(count, key = count.get)            
    print(new[0],new[1])
    change_map  = np.reshape(output,(new[0] - 4, new[1] - 4))
    
    return least_index, change_map

def find_vector_set(diff_image, new_size):
   
    i = 0
    j = 0
    vector_set = np.zeros((int(new_size[0] * new_size[1] / 25), 25))

    #print('\nvector_set shape',vector_set.shape)
    
    while i < vector_set.shape[0]:
        while j < new_size[0]:
            k = 0
            while k < new_size[1]:
                block   = diff_image[j:j+5, k:k+5]
                #print(i,j,k,block.shape)
                feature = block.ravel()
                vector_set[i, :] = feature
                k = k + 5
            j = j + 5
        i = i + 1
        
            
    mean_vec   = np.mean(vector_set, axis = 0)    
    vector_set = vector_set - mean_vec
    
    return vector_set, mean_vec

def find_PCAKmeans(image1, image2):
    diff_image = abs(image1 - image2)
    
    new_size = np.asarray(image1.shape) / 5
    new_size = new_size.astype(int) * 5 
    vector_set, mean_vec = find_vector_set(diff_image, new_size)
    pca     = PCA()
    pca.fit(vector_set)
    EVS = pca.components_
        
    FVS     = find_FVS(EVS, diff_image, mean_vec, new_size)
    
    print('\ncomputing k means')
    
    components = 3
    least_index, change_map = clustering(FVS, components, new_size)
    
    change_map[change_map == least_index] = 255
    change_map[change_map != 255] = 0
    
    change_map = change_map.astype(np.uint8)
    kernel     = np.asarray(((0,0,1,0,0),
                             (0,1,1,1,0),
                             (1,1,1,1,1),
                             (0,1,1,1,0),
                             (0,0,1,0,0)), dtype=np.uint8)
    cleanChangeMap = cv2.erode(change_map,kernel)
    st.image(cleanChangeMap, caption='Change map', use_column_width=True)
    # cv2.imwrite("changemap1.jpg", change_map)
    cv2.imwrite("cleanchangemap1.jpg", cleanChangeMap)

def add_bg_from_url():
    st.markdown(
         f"""
         <style>
         .stApp {{
             background-image: url("https://cdn.downtoearth.org.in/library/large/2022-10-19/0.32197700_1666181610_earth.jpg");
             background-attachment: fixed;
             background-size: cover
         }}
         </style>
         """,
         unsafe_allow_html=True
     )



st.set_page_config(page_title='Satellite Image Change Detection', page_icon=':earth_americas:', layout='wide')
st.title('Efficient Change Map Detection from Imagery Data using Machine Learning Approach')
st.markdown('This app allows you to upload two satellite images and performs change detection between them.')
import streamlit as st
import matplotlib.pyplot as plt
import numpy as np
import cv2
from sklearn.cluster import KMeans

st.set_option('deprecation.showfileUploaderEncoding', False)
add_bg_from_url()


# Upload two images
uploaded_files = st.file_uploader("Choose two images...", type=['jpg', 'jpeg', 'png'], accept_multiple_files=True)

if uploaded_files is not None:
    # Check if two images have been uploaded
    if len(uploaded_files) == 2:
        image1 = plt.imread(uploaded_files[0])
        image2 = plt.imread(uploaded_files[1])

        # Flatten the images into a 2D array
        image1_flat = image1.reshape(-1, 3)
        image2_flat = image2.reshape(-1, 3)

        # Perform K-means clustering on the flattened images
        kmeans1 = KMeans(n_clusters=5).fit(image1_flat)
        kmeans2 = KMeans(n_clusters=5).fit(image2_flat)

        # Generate labels for each pixel based on the cluster assignments
        labels1 = kmeans1.labels_
        labels2 = kmeans2.labels_

        # Calculate the similarity score between the two images
        similarity_score = np.mean(labels1 == labels2)

        # Display the similarity score
        st.write(f'Similarity score: {similarity_score}')

        # Calculate the difference image
        diff = cv2.absdiff(image1, image2)

        # Threshold the difference image to identify areas of change
        thresh = cv2.threshold(diff, 25, 255, cv2.THRESH_BINARY)[1]

        # Find contours in the thresholded image
        contours, hierarchy = cv2.findContours(thresh, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)

        # Draw the contours on the original image
        #result = cv2.drawContours(image1.copy(), contours, -1, (0, 255, 0), 2)

        # Display the change map
        #st.image(result, caption='Change map', use_column_width=True)

        # Save the result to a file
        #cv2.imwrite("change_map.jpg", result)
        find_PCAKmeans(image1, image2)

    else:
        st.write('Please upload two images.')

